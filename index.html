<style>
	* {
		font-family: monospace;
		/*font-family: times;*/
		/*font-size:  12px;*/
	}
	h1 {
		font-size: 22px;
	}
	h2 {
		font-size: 20px;
	}
	h3 {
		font-size: 19px;
	}
	date {
		color: grey;
		/*display: block;*/
	}
	code {
		background-color: #cccccc;
	}
	* {
		font-size:  18px;
	}
</style>

<h1>h4sh's super serious blog</h1>

<title>h4sh's blog</title>

<body>

<section>
	<h2 id=posts>Posts</h2>

	<article>
		<h3 id=tips-for-problem-solving><a href=#tips-for-problem-solving>Tips for problem solving</a></h3>

		<date>Some time in 2023</date>

		<p>Problem solving is all about the attitude. For me, I find that the best attitude that works for solving any problem (no matter how urgent/important it is) is <strong>steadfastness</strong>. Being calm, collected, no matter the amount of raging hormones and emotions rushing through your system (such as in the case of a critical incident or very emotional event), and knowing that you can do it, or at least can make a dent in it. Take it one step at a time.</p>
		<p>The most important thing to remember is confidence. Go into a problem thinking that you have what it takes to at least <em>do something about it</em>. Not everything is achievable by you, and many things not achievable by you alone; but if you punch a wall hard enough long enough eventually you will at least leave some sort of mark. It's okay to not be able to make a giant breakthrough. Just stay calm and keep trying until you are too tired.</p>
		<p>The first thing to do is breathe. Don't ever forget to breathe. Slow down your pace, stop panicking if you are, orient yourself.</p>
		<p>Then, decide whether or not this is a problem / task that needs some careful planning. If it does, take out your favorite planning tool, be that a blank piece of paper, your notebook, a text editor, tablet, or just an app on your phone. Maybe you like a bunch of sticky notes. The point is to have your most comfortable tool to dump out all your thoughts in a semi-organized way. Don't focus too much on formality - just take note of everything you think of, and your process.</p>
		<p>If there are many things to try and experiment with, make sure the attempts are logged each with its result. Kind of like a science experiment. Record all your inputs and outputs. A spreadsheet could be really good for this. Make sure you save things along the way, take photos of paper copies, make copies to the cloud, etc. When something works, make sure you never lose that so you can reproduce it later. This goes for pentests, log searching queries ran during incident response, home renovation, science experiments, fixing code, self help and literally anything else that's trial-and-error.</p>
		<p>Don't be afraid to ask for help (obviously, duckduckgo it and do your own homework first). When asking others for help, make sure you include what you have tried and describe the problem as specifically as you can so to not waste their time. For asking technical/programming questions the smart way, there's a <a href="http://www.catb.org/~esr/faqs/smart-questions.html">good article by esr</a> for hackers.</p>
		<p>That's generally the way I approach problems. I have done a lot of CTF challenges, responded to lots of incidents, hacked a lot of things and debugged a lot of outright disgusting code. It mostly works. And when it doesn't, that steadfastness allows me to say that I have tried hard enough, made a dent, learned something, and it's okay to fail.</p>

	</article>
	<code>----------------------------</code>

	<article>

	<h3 id=dependable-dependecies><a href=#dependable-dependecies>On dependable dependency systems</a></h3>

	<date>April 2023</date>

	<p>To have a dependable dependency/packaging/third party libaries system, you need at least these things:</p>

	<ol>
	<li>versioning</li>
	<li>a parseable file that has all (including recursive) dependencies, versions and how they relate to each other</li>
	<li>a way to easily verify where the code of the dependency comes from (and who wrote it)</li>
	<li>a way to verify that it hasn't been tampered with (checksums)</li>
	<li>a way to reproduce builds that can be verified</li>
	</ol>

	<p>Let's start with Python's pip. Pip (pypi) does not have lockfiles; <code>requirements.txt</code> does not come with recursive dependencies and there are no checksums to verify anything. Pypi's "link to github" or other links project version control/websites are self-published by the author, separate to the actual versions of the published packages. To make things worse, typosquatted packages can have the same link to git and the official project websites, have the same descriptions, but actual malware when you run pip install. Pip does not have any kind of 'reproducible builds' for wheels and eggs either. That's why when using pip, using virtual environments (<code>virtualenv</code>, <code>python -m venv</code>) is almost a must; otherwise, use more modern dependency management systems like <a target=_blank href=https://github.com/python-poetry/poetry>poetry</a>.</p>

	<p>What about javascript's npm? The situation looks a bit better. There are lockfiles alongside dependency description files, <code>package.json</code> and <code>package-lock.json</code>, and package-lock.json does contain checksums for verification. The package-lock.json file can be parsed to generate an SBOM (Software bill of materials), since it includes recursive dependencies and versions of every package that needs to be pulled in. However, npm packages are still self-published; there is no verifiable link between the name of the package (which is what really gets installed and executed) and source code control (like git). A very similar situation exists for Ruby's <code>Gemfile</code> and <code>Gemfile.lock</code>, as well as Rust's Cargo.</p>

	<p>Java is a mess. For Maven, lockfiles do not exist, and there is currently no way to generate lists of all dependencies without external tools like <code>spdx-sbom-generator</code>. Same goes for Gradle, which needs something like <code>cyclonedx-gradle-plugin</code>. Most gradle projects are also distributed with a wrapper script for gradle itself, <code>gradlew[.bat]</code>. God knows if that's been modified.</p>

	<p>The problem here is centralized package repositories/registries. They need hosting, management, which means they often belong to big corporations; and they are usually ripe with malware. They are a giant target for both cyber criminals and greedy corporations; the left-pad and kik incident where npm forcibly transferred the ownership of a package name from an open-source developer to a messaging app company shows that legal action on centralized repositories can all of the sudden break half the web.</p>

	<p>The good example I want to mention here is Golang. In golang, you directly reference a URL-like format (github.com/username/repo) for the dependency, and its version is in <code>go.mod</code> and checksums in <code>go.sum</code>. This directly ties the source code repository with the package and the account that wrote it. <a target=_blank href=https://hackernoon.com/building-reproducible-verifiable-binaries-with-golang>Reproducible builds are possible</a> if the same version of go is used, with <code>-trimpath</code> to remove the build path and <code>-ldflags=-buildid=</code> to stop the buildid from changing.</p>

	<p>The software landscape moves too fast and is too dangerous for bad dependency systems; dependency hell is everywhere, but it doesn't have to be. With dependency systems that support lockfiles, checksums and reprodicible builds, your code projects will be more secure and more maintainable.</p>

	</article>
	
	

	<code>----------------------------</code>

	<article>
	<h3 id=on-ctrl-f><a href=#on-ctrl-f>On control-F</a></h3>

	<date>Some time in 2023</date>

	<p>I am often surprised by the number of people who don't intuitively use Ctrl+F when browsing the web. In many browsers, where "Highlight All" is something you can do when doing Ctrl+F (or Cmd+F if you're on mac), you can do some very useful ad-hoc thematic analysis of articles.</p>

	<p>For example, if you're reading an article on a review of a certain social media platform but there's no mention of the word "ads" or "advertisement", that could be an intentional omission, or something the author forgot to mention; if it's an article about the COVID pandemic and how vaccines are bad for your kids but there's no single mention of the word "study" or "studies", then where are they getting the proof from?</p>

	<p>If the website you are using is too cluttered (or have too many irrelevant annoying things like ads), then use reader mode by doing Ctrl+Alt+R on Linux/Windows to toggle to a much easier to view interface with consistent fonts. Most websites that have semantic HTML tags wrapping elements like <code>&ltsection&gt</code> and <code>&ltarticle&gt</code> should support reader mode.</p>
	</article>
	<code>----------------------------</code>

	<article>
	<h3 id=why-no-framework><a href=#why-no-framework>Why I am not using a "framework"</a></h3>
	<date>April 2023</date>


	<p>These days, everyone (who isn't using Wordpress) is using Jekyll, Hugo or some kind of markdown-based blog generator.</p>

	<p>Many devs would spend days building out a blog framework and have their first blog entry about the blog framework and then.. almost no other entries for 3 months?</p>

	<p>So I am here instead writing a blog in plain HTML/CSS/JS (currently there's no JS), with the first entry being about why I don't have a framework then maybe no other entries for another 3 months. Who knows.</p>

	<p>Frameworks add abstraction to manual controls. The "source of truth", at the end of the day, is what's sent from the server to your browser. The built HTML code. Often with 500 different javascript libraries and CSS map files, in the case of big frontend frameworks. They come with abstracted ways to do very straight forward things that HTML allows you to do, even just for including an image.</p>

	<p>Writing plain HTML, I can control absolutely every last element without being "hacky" to bypass those "features".</p>

	<p>But when it comes to blogs, the presentation matters way less than the content - the fact that when you load a website nowadays and 90% of it is actually Javascript dependencies and boiletplated crap and only 10% is the actual content is messed up.</p>

	<p>We have insanely fast computers and phones nowadays with a massive amount of computing power. We can do so much with it - yet we are stuck loading websites that take more than 5000 milliseconds because we don't care about our footprint. We don't care about the final impact, the actual code that will be transferred across submarine cables from North Virginia to thousands of locations across the world, millions of times a day.</p>

	<p>That's why I am handwriting my website. I can run <code>wc index.html</code> on my page and it will be less than a 50MB bundle of npm packages.</p>

	</article>
	

	<!-- <hr> -->
</section>
<code>----------[ EOF ]-----------</code>

</body>